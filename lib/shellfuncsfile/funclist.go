package shellfuncsfile

/*
 * funclist.go
 * Shell function to print the list of functions we offer.
 * By J. Stuart McMurray
 * Created 20240728
 * Last Modified 20240928
 */

import (
	"bytes"
	"fmt"
	"slices"
	"strings"
	"text/tabwriter"
	"text/template"
)

const (
	// DocPrefix indicates a line is meant to be used for documenting a
	// function.
	DocPrefix = "# TABDOC:"
	// ListFuncName is the name of the function generated by GenFuncList.
	ListFuncName = "tab_list"
	// ListFuncDesc is the description for sff_list
	ListFuncDesc = "This function list"
)

// funcListTemplate makes a nice table of TABDOC'd functions.
var funcListTemplate = template.Must(template.New("funcList").Parse(
	ListFuncName + `() {
{{ range . }}        echo '{{ . }}'
{{ end }}}` + "\n",
))

// GenFuncList generates a function which prints a list of functions from the
// lines starting with DocPrefix in s.
//
// It makes a two-column table using the first word after DocPrefix for the
// first column and the rest of the line for the second column.
// The lines in the table will be sorted in lexicographical order.
func GenFuncList(s string) ([]byte, error) {
	/* Tabwriter for table-making. */
	buf := new(bytes.Buffer)
	tw := tabwriter.NewWriter(buf, 2, 8, 2, ' ', 0)

	/* Add our own function to the table. */
	fmt.Fprintf(tw, "%s\t- %s\n", ListFuncName, ListFuncDesc)

	/* Add each line to the table. */
	for _, line := range strings.Split(s, "\n") {
		/* Don't care about non-doc lines. */
		if !strings.HasPrefix(line, DocPrefix) {
			continue
		}

		/* Get the first word and rest of the line. */
		line = strings.TrimPrefix(line, DocPrefix)
		line = strings.TrimSpace(line)
		if "" == line { /* Need something to report. */
			continue
		}
		name, desc, _ := strings.Cut(line, " ")

		/* Add it to the help table. */
		fmt.Fprintf(
			tw,
			"%s\t- %s\n",
			strings.TrimSpace(name),
			strings.TrimSpace(desc),
		)
	}
	tw.Flush()

	/* Clean up and sort table. */
	lines := strings.Split(buf.String(), "\n")
	lines = slices.DeleteFunc(lines, func(s string) bool {
		return "" == s
	})
	slices.Sort(lines)
	lines = slices.Compact(lines)

	/* Single-quotes will cause us problems.  Easy answer is to quote them
	outside of single quotes. */
	for i, line := range lines {
		lines[i] = strings.ReplaceAll(line, `'`, `'\''`)
	}

	/* Roll into a shell function. */
	ret := new(bytes.Buffer)
	if err := funcListTemplate.Execute(ret, lines); nil != err {
		return nil, fmt.Errorf("rolling shell function: %w", err)
	}

	return ret.Bytes(), nil
}
